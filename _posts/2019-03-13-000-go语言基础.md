---
layout:     post
title:      2019-03-13-000-go语言基础
subtitle:    "\"2019-03-13-000-go语言基础\""
date:       2019-03-13
author:     PZ
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - GoLang
---

## 002-go语言基础

[TOC]

### 1 关键字

```
break	default	func	interface	select
case	defer	go	map	struct
chan	else	goto	package	switch
const	fallthrough	if	range	type
continue	for	import	return	var
```

36 个预定义标识符

```
append	bool	byte	cap	close	complex	complex64	complex128	uint16
copy	false	float32	float64	imag	int	int8	int16	uint32
int32	int64	iota	len	make	new	nil	panic	uint64
print	println	real	recover	string	true	uint	uint8	uintptr
```


### 2 go 程序的基本组成


```
package main

// 导入依赖
import (
	"fmt"
)

// 静态全局变量
const c = "C"
// 全局变量
var v int = 5
// 定义结构体
type T struct{}
// 初始化
func init() {
	// initialization of package
}

func main() {
	var a int
	Func1()
	// ...
	fmt.Println(a)
}

func (t T) Method1() {
	//...
}

func Func1() { // exported function Func1
	//...
}
```

- 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
- 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
- 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。
- 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

### 3 常用数据类型

- 结构体

---

```
package main

import "fmt"

// 结构体
type person struct {
	name string
	age int
}


// 结构体继承

type Human struct {
	name string
	age int
	weigth int
}
type Skills []string

type Student struct {
	Human
	Skills
	Speciality string
}

// 使用结构体

func example1(){

	// 声明
	var a_person person
	a_person.age = 10
	a_person.name = "HUPAN"

	// 声明2 注意顺序
	b_person := person{"hupan",10}

	// 声明3
	P := person{age:24, name:"Tom"}

	// 声明3
	P1 := new(person)
	P1.name = "adfa"
	P1.age = 12

	fmt.Println(a_person)
	fmt.Println(b_person)
	fmt.Println(P)
	fmt.Println(*P1)

}


func example2(){
	hupan := Student{Human{"hupan",35,100},[]string{"d"},"huapn"}
	fmt.Println("Her name is ", hupan.name)
}

func main() {

	example1()
	example2()
}

```

--- 

- 例子

```
package main

import (
	"errors"
	"fmt"
)

// 变量
func bianliang() {

	//定义三个类型都是“type”的变量
	var vname1, vname2, vname3 int
	vname1, vname2, vname3 = 1, 2, 3
	fmt.Println(vname1, vname2, vname3)

	//定义变量并初始化值
	var vname int = 4
	fmt.Println(vname)

	var vname6 = 6
	fmt.Println(vname6)

	//简化
	vname7 := 7
	fmt.Println(vname7)
}

// 常量
func changliang() {
	const PI = 3.1415
	const PI1 float32 = 3.14
	fmt.Println(PI, PI1)
}

// 内置类型
func neizhileixin() {

	// bool
	var enabled, disabled = true, false
	valid := false
	fmt.Println(enabled, disabled, valid)

	// 数值
	var b int32 = 123
	c := 123.1231
	fmt.Println(b, c)

	// 字符串
	str1 := "Konichiwa"
	str2 := `sdfadfsd`
	str3 := `dsfadsf
				sdfaf `
	fmt.Println(str1, str2, str3)

	// 修改字符串
	s := "hello"
	c1 := []byte(s) // 将字符串 s 转换为 []byte 类型
	c1[0] = 'c'
	s2 := string(c1) // 再转换回 string 类型
	fmt.Printf("%s\n", s2)
}

// 错误类型
func errorinfo() {

	err := errors.New("emit macho dwarf: elf header corrupted")
	if err != nil {
		fmt.Print(err)
	}
}

// 常用技巧 分组声明
func fenzushengming(){

	const(
		PI = 3.14
		E = 0.26343
	)


	var(
		i int = 1
		pi float32 = 1
		prefix string = "1"
	)

	fmt.Println(i,pi,prefix)
	fmt.Println(PI,E)

}



func main() {
	bianliang()
	changliang()
	neizhileixin()
	errorinfo()
	fenzushengming()
}

```


- 布尔 `var b bool = true` `! $$ ||`
- int (操作系统相关) float

```
int8（-128 -> 127）
int16（-32768 -> 32767）
int32（-2,147,483,648 -> 2,147,483,647）
int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）
uint8（0 -> 255）
uint16（0 -> 65,535）
uint32（0 -> 4,294,967,295）
uint64（0 -> 18,446,744,073,709,551,615）
float32（+- 1e-45 -> +- 3.4 * 1e38）
float64（+- 5 * 1e-324 -> 107 * 1e308）
```

### 4 运算符优先级

```
优先级 	运算符
 7 		^ !
 6 		* / % << >> & &^
 5 		+ - | ^
 4 		== != < <= >= >
 3 		<-
 2 		&&
 1 		||
```

### 5 类型别名

```
类型别名
```

### 6 字符类型 unicode 

> https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.5.md


### 6.5 流程处理


```
package main

import "fmt"

// golang的流程控制

// 条件判断
func ifelse(){

	// 流程控制
	// 条件判断语句里面允许声明一个变量
	if i:=1;i==1{
		fmt.Println(i)
	}else{
		fmt.Println("haha")
	}
}

// GOTO

func mygoto() {
	i := 0
Here:   //这行的第一个词，以冒号结束作为标签
	println(i)
	i++
	goto Here   //跳转到Here去
}


// switch

func myswitch(){

	i := 10
	switch i {
	case 1:
		fmt.Println("i is equal to 1")
	case 2, 3, 4:
		fmt.Println("i is equal to 2, 3 or 4")
	case 10:
		fmt.Println("i is equal to 10")
	default:
		fmt.Println("All I know is that i is an integer")
	}
}


func main() {
	ifelse()
	myswitch()
}

```


### 7 字符串处理 `strings 和 strconv 包`

> https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.7.md


### 8 指针

`var intP *int`



### 9 函数传递变长参数

> 如果函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。

```
func Greeting(prefix string, who ...string)
Greeting("hello:", "Joe", "Anna", "Eileen")
```


### 10 函数基础


```
package main

import "fmt"

// 函数

// 常见例子1
func funname1(var_i int,var_j int) int {
	return var_i +var_j
}

// 多个值返回
func funname2(var_i int , var_j int) (int, int) {

	return var_j, var_i
}


// 多个值返回 更好的方式
func funname3(var_i int , var_j int) (result1 int, result2 int) {

	result1 = var_j
	result2 = var_i
	return
}

// 变参 不定量参数
func myfunc(arg ...int) {
	// 变量arg是一个int的slice
	for _, n := range arg {
		fmt.Printf("And the number is: %d\n", n)
	}
}

// 传值和传址

// 指针方式
// Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针
func mypointfunc(i *int) int{
	*i = *i + 1
	return *i
}


func main() {

	fmt.Println(funname1(1,2))

	fmt.Println(funname2(1,2))
	fmt.Println(funname3(1,2))

	// 调用方式1
	slice := []int{7,9,3,5,1}
	myfunc(slice...)
	// 调用方式2
	myfunc(1,2,3,4,5,6)

	// 传址
	a := 1
	x1 := mypointfunc(&a)
	fmt.Println(x1,a)

}

```


#### 1 函数类型

- 普通的带有名字的函数
- 匿名函数或者lambda函数（参考 第 6.8 节）
- 方法（Methods，参考 第 10.6 节）


#### 2 不支持函数重载

#### 3 函数形式

```
func f2(a, b int) (int, int, int){
    
}

- a, b int : 形参
- int, int, int ： 返回

or

- 也可以 `命名的返回值` `推荐`
func getX2AndX3_2(input int) (x2 int, x3 int) {
    x2 = 2 * input
    x3 = 3 * input
    // return x2, x3
    return
}
```

#### 4 值传递，址传递

```
- 值传递
func MultiPly3Nums(a int, b int, c int) int {
    // var product int = a * b * c
    // return product
    return a * b * c
}
```

- 址传递

```
`不需要有返回值`

func Multiply(a, b int, reply *int) {
    *reply = a * b
}
func main() {
    n := 0
    reply := &n
    Multiply(10, 5, reply)
    fmt.Println("Multiply:", *reply) // Multiply: 50
}
```

#### 5 形参变长怎么办

`func myFunc(a, b, arg ...int) {}`

```
package main

import "fmt"

func main() {
	x := min(1, 3, 2, 0)
	fmt.Printf("The minimum is: %d\n", x)
	// slice 类型的变量 slice 中，则可以通过 slice...
	slice := []int{7,9,3,5,1}
	x = min(slice...)
	fmt.Printf("The minimum in the slice is: %d", x)
}

func min(s ...int) int {
	if len(s)==0 {
		return 0
	}
	min := s[0]
	for _, v := range s {
		if v < min {
			min = v
		}
	}
	return min
}
```

##### 1 变长参数的类型并不是都相同 怎么办

- 使用结构

```
type Options struct {
	par1 type1,
	par2 type2,
	...
}

F1(a, b, Options {par1:val1, par2:val2})
```

- 使用空接口


#### 6 defer 用法

- 类似java的 `finally` 关键功能

> 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数

```
package main

import "fmt"

func trace(s string)   { fmt.Println(s,"------------------------ start :") }
func untrace(s string) { fmt.Println(s,"------------------------ end  :") }

func a() {
	trace("a")
	defer untrace("a")

	fmt.Println("do something a")
}

func b() {
	trace("b")
	defer untrace("b")

	fmt.Println("do something b")
	a()
}

func main() {
	b()
}
```

#### 7 内置函数：不用import使用的函数

名称|说明
---|---
close|用于管道通信
len、cap|len 用于返回某个类型的长度或数量（字符串、数组、切片、map<br> 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
new、make|new 和 make 均是用于分配内存：new<br> 用于值类型和用户定义的类型，如自定义结构，make <br> 用于内置引用类型（切片、map<br> 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、<br>make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T<br> 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。<br>make(T) 返回类型 T 的初始化之后的值，<br>因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 <br>节和第 14.2.1 节）new() 是一个函数，不要忘记它的括号
copy、append|用于复制和连接切片
panic、recover|两者均用于错误处理机制
print、println|底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包
complex、real imag|用于创建和操作复数（详见第 4.5.2.2 节）

#### 8 递归函数 不用

#### 9 回调函数（函数是参数）

```
package main

import (
	"fmt"
)

func main() {
	callback(1, Add)
}

func Add(a, b int) {
	fmt.Printf("The sum of %d and %d is: %d\n", a, b, a+b)
}

func callback(y int, f func(int, int)) {
	f(y, 2) // this becomes Add(1, 2)
}
```

#### 10 匿名函数（闭包）

- 创建

`fplus := func(x, y int) int { return x + y }`

- 调用

`fplus(3,4)`


```
package main

import "fmt"

func main() {
	f()
}
func f() {
	for i := 0; i < 4; i++ {
		g := func(i int) { fmt.Printf("%d ", i) } //此例子中只是为了演示匿名函数可分配不同的内存地址，在现实开发中，不应该把该部分信息放置到循环中。
		g(i)
		fmt.Printf(" - g is of type %T and has value %v\n", g, g)
	}
}
```

#### 11 函数作为返回值（闭包的应用）


```
package main

import "fmt"

func main() {
	// make an Add2 function, give it a name p2, and call it:
	p2 := Add2()
	fmt.Printf("Call Add2 for 3 gives: %v\n", p2(3))
	// make a special Adder function, a gets value 2:
	TwoAdder := Adder(2)
	fmt.Printf("The result is: %v\n", TwoAdder(3))
}

// 这是一个两个数相加的函数
func Add2() (func(b int) int) {
	return func(b int) int {
		return b + 2
	}
}

// 这是一个数加2的函数
func Adder(a int) (func(b int) int) {
	return func(b int) int {
		return a + b
	}
}
```


#### 12 使用闭包调试

```
package main

import (
	"log"
	"runtime"
)
func main() {
	// 这是一个闭包函数的应用
	where := func() {
		_, file, line, _ := runtime.Caller(1)
		log.Printf("%s:%d", file, line)
	}
	where()
	// some code
	where()
	// some more code
	where()
}
```

- 方法2：

```
package main

import (
	"log"
)

func main() {
	// 这是一个闭包函数的应用
	log.SetFlags(log.Llongfile)
	var where = log.Print
	where()

	where()

	where()
}
```

#### 13 计算函数执行时间


```
package main

import (
	"fmt"
	"time"
)

// 完成一个计算函数执行时间的套路

func get_time() (time.Time){
	start := time.Now()
	return start
}

func trace() (time.Time) {
	start_time := time.Now()
	return start_time
}

func untrace(start_time time.Time)(){
	end_time := time.Now()
	delta := end_time.Sub(start_time)
	//return delta
	fmt.Printf("run time %s\n", delta)
}

func test_fun(){
	start_time := trace()
	defer untrace(start_time)
	
	for i:=1;i<10;i++{
		time.Sleep(1)
	}
}

func main() {
	// 这是一个闭包函数的应用
	test_fun()
}

```


#### 14 main 和 init 函数


![image](https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/2.3.init.png?raw=true)

```

```

### 11 容器（数组、切片和 map）


- 例子

```
package main

import "fmt"

// 数组

func shuzu() {

	// 声明
	var arr [10]int
	// 赋值
	arr = [10]int{1,3,4,5}
	fmt.Println(arr)

	//
	arr1 := [10]int{1,3,4,5}
	fmt.Println(arr1)

	//
	c := [...]int{4, 5, 6}
	fmt.Println(c)


	// 二维数组
	doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}
	easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
	fmt.Println(doubleArray,easyArray)


}


// slice 切片

func qiepian(){

	// slice是引用类型

	slice := []byte {'a', 'b', 'c', 'd'}
	fmt.Println(slice)

	slice1 := []string{"dsfsdf","dsfadf"}
	fmt.Println(slice1)

	fmt.Println(slice[1:])
	fmt.Println(slice[len(slice)-2:len(slice)])

	// 容量
	fmt.Println(cap(slice))
	// append
	fmt.Println(append(slice, 'e'))
	// copy
	var slice3 []byte
	fmt.Println(copy(slice, slice3))
	fmt.Println(slice3,slice)

}


// map

func yingshe(){

	// 声明
	var numbers map[string]int
	numbers = map[string]int{"hupan":1}
	fmt.Println(numbers)

	// 声明2
	map2:= map[string]int{"hupan":1}
	fmt.Println(map2)

	// 声明3
	map3 := make(map[string]int)
	map3["hupan"] = 1
	fmt.Println(map3)

	// 长度
	fmt.Println(len(map3))

	// 是否存在
	csharpRating, ok := map3["pan"]
	if ok{
		fmt.Println("C# is in the map and its rating is ", csharpRating)
	} else{
		fmt.Println("We have no rating associated with C# in the map")
	}

	// 删除
	delete(map3,"hupan")
	fmt.Println(map3)

	// map也是一种引用类型
}


// make and new

func make_new(){

	// make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。
	// var := make(类型)

	//- 切片、映射和通道，使用make
	//- 数组、结构体和所有的值类型，使用new

	slice := make([]int,10)
	slice = append(slice, 1)
	slice = append(slice, 2)
	slice[3] = 3
	fmt.Println(slice)

	// new返回指针
	

}



func main() {
	shuzu()
	qiepian()
	yingshe()
	make_new()
}

```


#### 1 数组

> 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列

- 声明：`var identifier [len]type` like `var arr1 [5]int`

##### 1 数组常量

```

var arrAge = [5]int{18, 20, 15, 22, 16}

var arrLazy = [...]int{5, 6, 7, 8, 22}

var arrKeyValue = [5]string{3: "Chris", 4: "Ron"}

```

- 数组别名

```
type Vector3D [3]float32
var vec Vector3D
```

- 数组传递给函数

```
package main
import "fmt"

func main() {
	array := [3]float64{7.0, 8.5, 9.1}
	x := Sum(&array) // Note the explicit address-of operator
	// to pass a pointer to the array
	fmt.Printf("The sum of the array is: %f", x)
}

func Sum(a *[3]float64) (sum float64) {
	for _, v := range *a { // derefencing *a to get back to the array is not necessary!
		sum += v
	}
	return
}
```

#### 2 切片

- 声明 

```
var identifier []type
```

> 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量






### 12 包管理

> https://gowalker.org/search?q=gorepos <br> 可以在这里查看基础库信息


#### 1 常用包

```
archive/tar 和 /zip-compress：压缩(解压缩)文件功能。
fmt-io-bufio-path/filepath-flag:
    fmt: 提供了格式化输入输出功能。
    io: 提供了基本输入输出功能，大多数是围绕系统功能的封装。
    bufio: 缓冲输入输出功能的封装。
    path/filepath: 用来操作在当前系统中的目标文件名路径。
    flag: 对命令行参数的操作。　　
strings-strconv-unicode-regexp-bytes:
    strings: 提供对字符串的操作。
    strconv: 提供将字符串转换为基础类型的功能。
    unicode: 为 unicode 型的字符串提供特殊的功能。
    regexp: 正则表达式功能。
    bytes: 提供对字符型分片的操作。
    index/suffixarray: 子字符串快速查询。
math-math/cmath-math/big-math/rand-sort:
    math: 基本的数学函数。
    math/cmath: 对复数的操作。
    math/rand: 伪随机数生成。
    sort: 为数组排序和自定义集合。
    math/big: 大数的实现和计算。 　　
container-/list-ring-heap: 实现对集合的操作。
    list: 双链表。
    ring: 环形链表。

time-log:
    time: 日期和时间的基本操作。
    log: 记录程序运行时产生的日志,我们将在后面的章节使用它。
encoding/json-encoding/xml-text/template:
    encoding/json: 读取并解码和写入并编码 JSON 数据。
    encoding/xml:简单的 XML1.0 解析器,有关 JSON 和 XML 的实例请查阅第 12.9/10 章节。
    text/template:生成像 HTML 一样的数据与文本混合的数据驱动模板（参见第 15.7 节）。
net-net/http-html:（参见第 15 章）
    net: 网络数据的基本操作。
    http: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。
    html: HTML5 解析器。
runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建。
reflect: 实现通过程序运行时反射，让程序操作任意类型的变量。

```

---


### 13 接口（interface）与反射（reflection）

> Go 语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。

#### 1 接口

##### 1 go的接口是什么

> 接口定义了一组**方法（方法集）**，但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也**不能包含变量**。

##### 2 如何定义

- like: 一般包含0-3个方法

- 我们成为`接口类型`，接口类型可以用于`定义值` ，它可以等于`接收者类型`,从而进行不同接口实现。

```
type Namer(定义里接口类型 命名一般加er able &&) interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    ...
}
```


##### 3 例子

```
package main

import "fmt"

// 定义面积接口
type Shaper interface {
	Area() float32
}

// 类型
type Square struct {
	side float32
}

// 对类型的实现
func (sq *Square) Area() float32 {
	return sq.side * sq.side
}

// 另外的类型
type Rectangle struct {
	length, width float32
}

// 类型的实现
func (r Rectangle) Area() float32 {
	return r.length * r.width
}

func main() {

	r := Rectangle{5, 3} // Area() of Rectangle needs a value
	q := &Square{5}      // Area() of Square needs a pointer
	// shapes := []Shaper{Shaper(r), Shaper(q)}
	// or shorter
	shapes := []Shaper{r, q}
	fmt.Println("Looping through shapes for area ...")
	for n, _ := range shapes {
		fmt.Println("Shape details: ", shapes[n])
		fmt.Println("Area of this shape is: ", shapes[n].Area())
	}
}
```

#### 2 接口嵌套接口

一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。 like：

```
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

type File interface {
    ReadWrite
    Lock
    Close()
}

```

##### 1 例子

```
package main

import "fmt"

// 定义面积接口
type Shaper interface {
	Area() float32
}


type Bigshaper interface {
	Shaper
	Length() float32
}

// 类型
type Square struct {
	side float32
}

// 对类型的实现
func (sq *Square) Area() float32 {
	return sq.side * sq.side
}

// 另外的类型
type Rectangle struct {
	length, width float32
}

// 类型的实现
func (r Rectangle) Area() float32 {
	return r.length * r.width
}

func (r Rectangle) Length() float32{
	return r.length + 2
}

func main() {

	r := Rectangle{5, 3} // Area() of Rectangle needs a value
	q := &Square{5}      // Area() of Square needs a pointer
	// shapes := []Shaper{Shaper(r), Shaper(q)}
	// or shorter
	shapes := []Shaper{r, q}
	fmt.Println("Looping through shapes for area ...")
	for n, _ := range shapes {
		fmt.Println("Shape details: ", shapes[n])
		fmt.Println("Area of this shape is: ", shapes[n].Area())
	}


	r1 := Rectangle{5, 3}
	var a1 Bigshaper
	a1 = r1
	fmt.Println(a1.Area())
	fmt.Println(a1.Length())
}

```

#### 3 接口调用的重要问题

- 在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：
    - 指针方法可以通过指针调用
    - 值方法可以通过值调用
    - 接收者是值的方法可以通过指针调用，因为指针会首先被解引用
    - 接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址

- Go 语言规范定义了接口方法集的调用规则：
    - 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集
    - 类型 T 的可调用方法集包含接受者为 T 的所有方法
    - 类型 T 的可调用方法集不包含接受者为 *T 的方法

> 指针的方式使用


```
package main

import (
	"fmt"
	"math"
)

type Square struct {
	side float32
}

type Circle struct {
	radius float32
}

type Shaper interface {
	Area() float32
}

func main() {
	var areaIntf Shaper
	sq1 := new(Square)
	sq1.side = 5

	areaIntf = sq1
	print(areaIntf.Area())
	// Is Square the type of areaIntf?
	if t, ok := areaIntf.(*Square) ; ok{
		fmt.Printf("The type of areaIntf is: %T\n", t)
	}
	if u, ok := areaIntf.(*Circle); ok {
		fmt.Printf("The type of areaIntf is: %T\n", u)
	} else {
		fmt.Println("areaIntf does not contain a variable of type Circle")
	}
}

func (sq *Square) Area() float32 {
	return sq.side * sq.side
}

func (ci *Circle) Area() float32 {
	return ci.radius * ci.radius * math.Pi
}
```


#### 4 反射

> 反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。反射可以在运行时检查类型和变量，例如它的大小、方法和 动态 的调用这些方法。这对于没有源代码的包尤其有用。


#### 5 接口与动态类型

> Go 没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系。

> 和其它语言相比，Go 是唯一结合了**接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换**的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。


```
package main

import "fmt"

type IDuck interface {
	Quack()
	Walk()
}

func DuckDance(duck IDuck) {
	for i := 1; i <= 3; i++ {
		duck.Quack()
		duck.Walk()
	}
}

type Bird struct {

	// ...
}

func (b *Bird) Quack() {
	fmt.Println("I am quacking!")
}

func (b *Bird) Walk()  {
	fmt.Println("I am walking!")
}

func main() {
	b := new(Bird)
	DuckDance(b)
}
```

#### 6 Go中是如何进行面向对象的

> Go 没有类，而是松耦合的类型、方法对接口的实现。

##### 1 封装

包范围内的：通过标识符首字母小写，对象 只在它所在的包内可见

可导出的：通过标识符首字母大写，对象 对所在包以外也可见

##### 2 继承

继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现

##### 3 多态

用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。





### 14 读写数据



#### 1 从命令行读取参数




### 14 go 数据库框架

> https://my.oschina.net/u/168737/blog/1531834



